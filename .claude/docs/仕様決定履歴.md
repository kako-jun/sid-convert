# sid-convert 仕様決定履歴

プロジェクト開発中に行った重要な仕様決定とその理由を時系列で記録します。

---

## 2025-11-17: プロジェクト開始

### Q1: 16分音符や付点音符は無視でOK？
**決定**: 無視する（quarter, eighth, half, wholeのみサポート）

**理由**:
- ベース演奏では基本的な音価で十分
- 細かい音価は頻度が低い
- シンプルさを優先し、複雑さを避ける
- 必要に応じて後から追加可能

**影響範囲**:
- `convert.rs`の`ticks_to_duration()`関数
- 出力YAML形式
- ドキュメント

---

### Q2: 音価は「quarter」「eighth」など英語でOK？
**決定**: 英語表記を採用

**理由**:
- プログラミングの標準的な用語
- YAML/JSONで扱いやすい
- 国際的な互換性
- 既存の音楽ソフトウェアとの整合性

**代替案**:
- 日本語: "四分音符", "八分音符" → 可読性は高いが技術的には非標準
- 数値: 1.0, 0.5 → 直感的だが音楽的意味が不明瞭

---

### Q3: テンポ変化や転調はどう扱う？
**決定**: 無視する

**ユーザーコメント引用**:
> "テンポ変化や転調はピアノでは重要だろうが、ベースにはあまり関係がない"

**理由**:
- ベース演奏の本質は音程とリズム
- テンポ変化を追跡する複雑さと得られる価値が見合わない
- 転調はベースの指板位置に影響しない（同じフレットで弾ける）

**技術的補足**:
- テンポ変化: MIDI的には可能だが、ベース練習には不要
- 転調: 音名表記なので転調情報は含まれない

---

### Q4: 拍子は4/4固定で良い？
**決定**: 4/4固定

**理由**:
- ベース音楽の大半は4/4拍子
- 他の拍子（3/4, 6/8等）でも音価計算は同じロジックで動作
- 拍子変化の検出は複雑度を増すが価値は低い

**将来の拡張**:
- 必要に応じてMIDIのTime Signatureイベントから拍子を読み取り可能

---

### Q5: ticksは残さなくていい？
**決定**: ticksは出力しない、音価のみ

**ユーザーコメント引用**:
> "ticksは残さなくていい。quarterなどでいい。"

**理由**:
- sid-note側で音価情報があれば十分
- tick数は実装詳細（MIDIファイルごとにTPQが異なる）
- 人間が読みやすい形式を優先

**YAMLフォーマット決定**:
```yaml
notes:
  - start: 0           # tick数は開始位置のみ残す（ソート・タイミング用）
    length: quarter    # 音価（人間可読）
    pitch: E2          # 音名
```

**start フィールドの扱い**:
- 開始tick は残す（ノートの順序とタイミング情報に必要）
- duration のtickは残さない（lengthで表現）

---

### Q6: YAML vs JSON vs XML?
**決定**: YAML形式

**理由**:
1. **人間可読性**: コメント追加可能、構造が直感的
2. **拡張性**: 将来的に運指情報やメタデータを追加しやすい
3. **sid-note側のパース**: Rustのserde_yamlで簡単

**比較**:

YAML（採用）:
```yaml
track: "Bass"
notes:
  - start: 0
    length: quarter
    pitch: E2
```

JSON:
```json
{
  "track": "Bass",
  "notes": [
    {"start": 0, "length": "quarter", "pitch": "E2"}
  ]
}
```

XML:
```xml
<output>
  <track>Bass</track>
  <notes>
    <note start="0" length="quarter" pitch="E2"/>
  </notes>
</output>
```

**決定理由**:
- YAML: 冗長性が低く、人間が編集しやすい
- JSON: 機械的には扱いやすいが可読性で劣る
- XML: 冗長すぎる

---

### Q7: ベース音域の定義
**決定**: E1（MIDIノート28）～ G3（MIDIノート55）

**根拠**:

| 音名 | MIDI番号 | 周波数 | 備考 |
|------|----------|--------|------|
| E1   | 28       | 41.2Hz | 4弦ベース最低音（開放E弦）|
| A1   | 33       | 55.0Hz | 開放A弦 |
| D2   | 38       | 73.4Hz | 開放D弦 |
| G2   | 43       | 98.0Hz | 開放G弦 |
| G3   | 55       | 196.0Hz| ベース高音域上限（実用的範囲）|

**検出ロジック**:
```rust
const E1: u8 = 28;
const G3: u8 = 55;
is_bass_range = note >= E1 && note <= G3
```

**代替案と却下理由**:
- C1～C4: 範囲が広すぎる（チェロ等を含む）
- E1～E3: 範囲が狭すぎる（ハイポジションを除外）

---

### Q8: ベーストラック検出の閾値
**決定**: ベース音域のノートが70%以上

**ロジック**:
```rust
is_bass_by_range = (bass_note_count / total_note_count) > 0.7
```

**閾値検討**:
- 50%: 低すぎる（メロディパートも誤検出）
- 70%: ✅ 適切（ベースらしいパートを検出）
- 90%: 高すぎる（ベースでも高音が混じると除外される）

**実例**:
- 純粋なベースパート: 通常90%以上がベース音域
- スラップベース（高音多め）: 70～80%程度
- メロディパート: 通常30%以下

---

### Q9: トラック名の検出（大文字小文字）
**決定**: 大文字小文字を区別しない

**実装**:
```rust
track_name.to_lowercase().contains("bass")
```

**対応する名前の例**:
- "Bass" ✓
- "BASS" ✓
- "bass" ✓
- "Bass Line" ✓
- "Electric Bass" ✓
- "Bassoon" ✓（ファゴット - 意図しない検出だが許容）

---

### Q10: 複数ベーストラック時の挙動
**決定**: ユーザーに選択を促す（自動選択しない）

**理由**:
- どのトラックが「正解」か自動判定は困難
- ユーザーの意図を尊重
- 誤った選択を避ける

**UX設計**:
```
Multiple bass tracks found. Please specify one with --track <number>:
  Track 1: Bass (42/50 bass notes)
  Track 2: Bass Line (38/40 bass notes)
```

**代替案と却下理由**:
- 「最初のトラックを自動選択」: ユーザーの意図と異なる可能性
- 「最もベース音域比率が高いトラックを選択」: 複雑で予測不能

---

### Q11: 音価の丸め処理（許容誤差）
**決定**: 各音価に対して適切な許容誤差を設ける

**ロジック**:
```rust
let quarters = ticks as f64 / tpq as f64;

if (quarters - 4.0).abs() < 0.25 { "whole" }
else if (quarters - 2.0).abs() < 0.25 { "half" }
else if (quarters - 1.0).abs() < 0.25 { "quarter" }
else if (quarters - 0.5).abs() < 0.125 { "eighth" }
```

**許容誤差の設定**:
- whole/half/quarter: ±0.25拍 (±25%)
- eighth: ±0.125拍 (±25%)

**理由**:
- 人間の演奏にはタイミングのゆらぎがある
- クォンタイズされていないMIDIファイルに対応
- 音楽的に自然な丸め

**エッジケース処理**:
```rust
else {
    // フォールバック: 最も近い音価を選択
    if quarters >= 3.0 { "whole" }
    else if quarters >= 1.5 { "half" }
    else if quarters >= 0.75 { "quarter" }
    else { "eighth" }
}
```

---

### Q12: エラーハンドリング方針
**決定**: ユーザーフレンドリーなメッセージと具体的な解決策を提示

**原則**:
1. 技術用語を避ける
2. 何が起きたかを明確に説明
3. 次に何をすべきか提示

**実例**:

❌ 悪い例:
```
Error: Vec<TrackInfo> is empty
```

✅ 良い例:
```
No bass tracks found in the MIDI file.
Try specifying a track manually with --track <number>
```

**エラー分類**:
- **ファイルエラー**: "Error reading MIDI file: {詳細}"
- **トラック検出失敗**: 代替手段を提案
- **YAML出力エラー**: "Error saving YAML file: {詳細}"

---

### Q13: デフォルト出力ファイル名
**決定**: `sid-convert.yaml`

**理由**:
- プロジェクト名と一致
- 拡張子で形式が明確
- 上書きリスクが低い（一般的な名前ではない）

**代替案と却下理由**:
- `output.yaml`: 汎用的すぎる
- `bass.yaml`: プロジェクトとの関連が不明瞭
- `{input_filename}.yaml`: 実装が複雑

---

### Q14: CLI引数の設計
**決定**:
```bash
sid-convert <FILE> [OPTIONS]
```

**オプション**:
- `-t, --track <TRACK>`: トラック番号指定
- `-o, --output <OUTPUT>`: 出力ファイル名
- `-h, --help`: ヘルプ表示
- `-V, --version`: バージョン表示

**設計原則**:
- POSIX準拠（短縮形と長形式）
- 必須引数を最小限に（`<FILE>`のみ）
- 分かりやすい名前（`--track`, `--output`）

---

### Q15: ライフタイム問題の解決方法
**技術的決定**: `Box::leak()`を使用

**問題**:
```rust
error[E0597]: `data` does not live long enough
```

**解決策**:
```rust
pub struct MidiParser {
    _data: Vec<u8>,              // 所有権保持
    smf: Smf<'static>,           // 'static参照
}

let data_static: &'static [u8] = Box::leak(data.clone().into_boxed_slice());
let smf = Smf::parse(data_static)?;
```

**代替案の検討**:

1. **Box::leak()** ✅ 採用
   - pros: シンプル、動作確実
   - cons: メモリリーク

2. **Rc/Arc**
   - pros: メモリ安全
   - cons: midlyが要求する'staticを満たせない

3. **自前のMIDIパーサー**
   - pros: 完全制御
   - cons: 実装コストが高すぎる

**決定理由**:
- CLIツールは短命（数秒で終了）
- メモリリークはOS終了時に解放される
- パフォーマンスへの影響なし

---

## 仕様変更履歴

### v0.1.0 (2025-11-17)
- 初期リリース
- 全機能実装完了
- 変更なし（初版）

---

## 今後検討すべき仕様

### 検討事項1: ベロシティ情報
**現状**: ベロシティを出力していない

**提案**:
```yaml
notes:
  - start: 0
    length: quarter
    pitch: E2
    velocity: 80  # 追加
```

**議論**:
- pros: 音の強弱を表現可能
- cons: ベース練習にはあまり重要でない
- **判断保留**: ユーザーフィードバック待ち

---

### 検討事項2: 複数トラックの一括出力
**現状**: 1トラックずつ処理

**提案**:
```yaml
tracks:
  - name: "Bass 1"
    notes: [...]
  - name: "Bass 2"
    notes: [...]
```

**議論**:
- pros: 複数ベースパートを含む曲に対応
- cons: ユースケースが不明瞭
- **判断保留**: 要件が明確になってから

---

### 検討事項3: JSON出力オプション
**提案**: `--format json` オプション追加

**議論**:
- pros: API連携が容易
- cons: 現状YAML で十分
- **優先度**: 低

---

## まとめ

プロジェクト開発中に15の主要な仕様決定を行いました。
全ての決定は以下の原則に基づいています：

1. **シンプルさ優先**: 複雑さを避け、実用的な機能に集中
2. **ユーザー中心**: ベース演奏者のニーズに焦点
3. **拡張性**: 将来的な機能追加を妨げない設計
4. **技術的実現性**: Rustとmidlyの制約内で実装

この履歴は今後の機能追加や仕様変更の際に参照すべき重要な記録です。
