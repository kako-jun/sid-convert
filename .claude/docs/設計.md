# sid-convert 設計仕様

## アーキテクチャ

### システム構成

```
[MIDIファイル]
     ↓
[MIDI Parser] ← midly
     ↓
[Bass Track Detection]
     ↓
[Note Extraction]
     ↓
[Note Conversion] → [音名変換] [音価変換]
     ↓
[YAML Export] ← serde_yaml
     ↓
[YAMLファイル]
```

## モジュール設計

### 1. main.rs - エントリーポイント
**責務**: CLI引数の解析、ユーザーインタラクション、エラーハンドリング

**主要構造体**:
```rust
struct Args {
    input: String,           // 入力MIDIファイルパス
    track: Option<usize>,    // トラック番号（オプション）
    output: String,          // 出力YAMLファイルパス
}
```

**処理フロー**:
1. CLIパーサーでコマンドライン引数を解析
2. MIDIファイルを読み込み
3. ベーストラックを検出
4. トラック選択（自動 or 手動）
5. ノート抽出
6. YAML出力

### 2. midi.rs - MIDI解析
**責務**: MIDIファイルの読み込み、ベーストラックの検出、ノート抽出

**主要構造体**:
```rust
pub struct MidiParser {
    _data: Vec<u8>,       // MIDIデータ（所有権保持用）
    smf: Smf<'static>,    // 解析済みMIDI（midlyのSmf構造体）
}

pub struct TrackInfo {
    index: usize,              // トラックインデックス
    name: Option<String>,      // トラック名
    bass_note_count: usize,    // ベース音域のノート数
    total_note_count: usize,   // 総ノート数
}
```

**主要メソッド**:
- `from_file(path: &str)`: MIDIファイル読み込み
- `get_ticks_per_quarter()`: TPQ（Ticks Per Quarter note）取得
- `find_bass_tracks()`: ベーストラック候補を検出
- `extract_notes(track_index)`: 指定トラックのノート抽出

**ベーストラック検出ロジック**:
```rust
// 条件1: トラック名に"Bass"を含む
is_bass_by_name = track_name.to_lowercase().contains("bass")

// 条件2: ベース音域のノートが70%以上
is_bass_by_range = (bass_note_count / total_note_count) > 0.7

// どちらかを満たせばベーストラックと判定
if is_bass_by_name || is_bass_by_range { ... }
```

### 3. convert.rs - ノート変換
**責務**: MIDIデータから人間が読みやすい形式への変換

**主要関数**:

#### `note_to_pitch(note: u8) -> String`
MIDIノート番号を音名に変換

```rust
// 例: 40 -> E2
// MIDIノート番号 = オクターブ * 12 + 音階インデックス
// オクターブ = (note / 12) - 1
// 音階 = note % 12
```

**音名テーブル**:
```
0:C, 1:C#, 2:D, 3:D#, 4:E, 5:F, 6:F#, 7:G, 8:G#, 9:A, 10:A#, 11:B
```

#### `ticks_to_duration(ticks: u32, tpq: u16) -> String`
Tick数を音価に変換

```rust
// quarters = ticks / tpq
// 4.0 ± 0.25 → "whole"
// 2.0 ± 0.25 → "half"
// 1.0 ± 0.25 → "quarter"
// 0.5 ± 0.125 → "eighth"
```

**許容誤差の理由**:
- 人間の演奏にはタイミングのゆらぎがある
- ±25%の誤差範囲で最も近い音価に丸める

#### `is_bass_range(note: u8) -> bool`
ベース音域判定

```rust
const E1: u8 = 28;  // 最低音
const G3: u8 = 55;  // 最高音
note >= E1 && note <= G3
```

**音域選定の理由**:
- E1（41.2Hz）: 4弦ベースの最低音
- G3（196.0Hz）: ベースの一般的な高音域上限

### 4. export.rs - YAML出力
**責務**: データ構造の定義とYAML形式での出力

**データ構造**:
```rust
#[derive(Serialize, Deserialize)]
pub struct Note {
    start: u32,      // 開始tick
    length: String,  // 音価（quarter等）
    pitch: String,   // 音名（E2等）
}

#[derive(Serialize, Deserialize)]
pub struct Output {
    track: String,      // トラック名
    notes: Vec<Note>,   // ノートリスト
}
```

**主要メソッド**:
- `new(track: String)`: 初期化
- `add_note(start, length, pitch)`: ノート追加
- `to_yaml()`: YAML文字列に変換
- `save_to_file(path)`: ファイルに保存

## データフロー

### ノート抽出の詳細フロー

```
1. MIDIイベントループ
   ↓
2. delta時間を累積してcurrent_tickを更新
   ↓
3. NoteOnイベント検出
   - velocity > 0: ノート開始を記録 (note → start_tick)
   - velocity = 0: ノート終了として処理（4へ）
   ↓
4. NoteOffイベント検出（またはvelocity=0のNoteOn）
   - duration = current_tick - start_tick
   - pitch = note_to_pitch(note)
   - length = ticks_to_duration(duration, tpq)
   - Output::add_note(start_tick, length, pitch)
```

**注意点**:
- NoteOnのvelocity=0はNoteOffと同じ扱い（MIDI仕様）
- 同時に複数の音が鳴る場合、HashMap で管理

## エラーハンドリング

### エラーケース

1. **ファイル読み込みエラー**
   - ファイルが存在しない
   - 読み込み権限がない
   → `std::io::Error`

2. **MIDI解析エラー**
   - ファイル形式が不正
   - 破損したMIDIデータ
   → `midly::Error`

3. **トラック選択エラー**
   - ベーストラックが見つからない
   - 指定したトラック番号が存在しない
   → ユーザーフレンドリーなメッセージで案内

4. **YAML出力エラー**
   - ディスク容量不足
   - 書き込み権限がない
   → `std::io::Error`

### エラーメッセージ設計

```rust
// 良い例（ユーザーフレンドリー）
eprintln!("No bass tracks found in the MIDI file.");
eprintln!("Try specifying a track manually with --track <number>");

// 悪い例（技術的すぎる）
eprintln!("Error: Vec<TrackInfo> is empty");
```

## パフォーマンス考慮事項

### メモリ管理
- **Box::leak()の使用**
  - midlyが'static参照を要求するため
  - プログラム終了時にOSがメモリを解放するため、短命なCLIでは問題なし
  - 長時間動作するサーバーでは要改善

### 計算量
- **トラック検出**: O(N * M)
  - N: トラック数
  - M: 各トラックのイベント数
- **ノート抽出**: O(M)
  - M: トラックのイベント数

**最適化の余地**:
- 現状のパフォーマンスで十分（MIDIファイルは通常数MB以下）
- 必要に応じてrayon等で並列化可能

## テスト戦略

### ユニットテスト
- **convert.rs**: 純粋関数のテストが容易
  - 各変換関数の境界値テスト
  - エッジケースのテスト

- **export.rs**: データ構造のテスト
  - YAML出力形式の検証
  - シリアライゼーション/デシリアライゼーション

### 統合テスト（将来的に）
- サンプルMIDIファイルを使用した全体テスト
- 既知の出力と比較

## 依存関係

```toml
[dependencies]
midly = "0.5"                               # MIDI解析
serde = { version = "1.0", features = ["derive"] }  # シリアライゼーション
serde_yaml = "0.9"                          # YAML出力
clap = { version = "4.5", features = ["derive"] }   # CLI
```

**選定理由**:
- **midly**: 高速、安全、依存関係が少ない
- **serde**: Rustのデファクトスタンダード
- **clap**: 強力なCLI機能、自動ヘルプ生成
